// ==UserScript==
// @name     WebResearcherJS1
// @include     *
// @require https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js
// @require https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js
// @require https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js
// @require https://unpkg.com/@popperjs/core@2
// @require https://cdnjs.cloudflare.com/ajax/libs/pell/1.0.6/pell.min.js
// @require https://cdnjs.cloudflare.com/ajax/libs/notify/0.4.2/notify.min.js

// @resource https://cdnjs.cloudflare.com/ajax/libs/pell/1.0.6/pell.css
// @resource https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css



// ==/UserScript==



/////////////// Hightlight + Annotate block //////////////////////
// highlight and annotate  when tilde(`) key is pressed

/// customizable variables
/// Go to https://keycode.info/ to find keycodes

var createNoteKeyCode = 55 ;  // corresponds to 1 on keyboard
var saveAnnotationsKeyCode= 50; // corresponds to 2 on keyboard
var loadAnnotationsKeyCode=51 ; // corresponds to 3 on keyboard
var startmqttKeyCode=52 ; // corresponds to 4 on keyboard

// controls the specs of the notes
var defaultNoteColor = "#ffffcc";
var defaultFont= "13px";
var defaultOpacity = "80%";





/////// variables used /////////
var note_count=1;
var webPageUrl = window.location.href.replace(/(^\w+:|^)\/\//, '');

// MQTT variables //
var broker = {
  hostname: '',
  port: ''
};
// MQTT client:
var client;
// client credentials:
var creds = {
  clientID: "wsbrowser_"+new Date().getUTCMilliseconds(),
  userName: '',
  password: ''
};
// topic to subscribe to when you connect:
var topic = '';





document.addEventListener('keydown', workerFunction);
function workerFunction(e){

    var toggleHighlight= false;

    if(e.ctrlKey){


        //////// save annotation block ///////
        /// Saves the annotations to local .txt file when Ctrl+3 is pressed
        if(e.keyCode==saveAnnotationsKeyCode){
            var dict = {};

            // grab all notes
            var allNotes=document.getElementsByClassName("ui-widget-content");
            var allNotes_html = ''

            for(var i=0;i<allNotes.length;i++){
                allNotes_html+= allNotes[i].outerHTML; // getting all notes
            }

            dict[webPageUrl] = allNotes_html;
            var encode_obj= encodeURIComponent(JSON.stringify(dict));
            var makeNewID = Number(new Date());
            var encode_obj1 = encode_obj.replaceAll("tooltip","tooltip"+ makeNewID);

            // save note  as text file
            var hiddenElement = document.createElement('a');
            hiddenElement.href = 'data:text/txt;charset=utf-8,' + encode_obj1;
            hiddenElement.target = '_blank';
            hiddenElement.download = webPageUrl +'.txt';
            hiddenElement.click();

            // add note to local storage
            localStorage.setItem(webPageUrl, allNotes_html.replaceAll("tooltip","tooltip"+ makeNewID));

          }


         /// End of save annotation block///





          /////////////// Upload annotations block //////////////////////
          // Allow user to upload annotations when the Ctrl+2 key is pressed- code adapted from
          //https://stackoverflow.com/questions/19038919/is-it-possible-to-upload-a-text-file-to-input-in-html-js/19039880

        if(e.keyCode==loadAnnotationsKeyCode){

            // const cat1 = localStorage.getItem(window.location.hostname + window.location.pathname);
            loadAll(window.location.hostname + window.location.pathname);

            // load from local storage
            const cat = localStorage.getItem(webPageUrl);
            console.log(cat);

            var AnnotationsBlock = document.createElement('div');
            AnnotationsBlock.id ="ImportedAnnotations";
            AnnotationsBlock.innerHTML=cat;
            document.body.appendChild(AnnotationsBlock);

            function uploadText() {
              return new Promise((resolve) => {
                // create file input1`1
                const uploader = document.createElement('input')
                uploader.type = 'file'
                uploader.style.display = 'none'
                uploader.multiple=true;

                // listen for files
                uploader.addEventListener('change', () => {
                  const files = uploader.files

                  if (files.length) {
                    for(var dd=0;dd<files.length;dd++){
                      const reader = new FileReader()
                      reader.addEventListener('load', () => {
                        uploader.parentNode.removeChild(uploader)
                        resolve(reader.result)
                      })
                      reader.readAsText(files[0])
                    }

                  }
                })

                // trigger input
                document.body.appendChild(uploader)
                uploader.click()
              })
            }

          // usage example
            uploadText().then(text => {
              //once loaded check update the html page if the dictionary has the notes for the current URL
              var UserUploadedAnnotaions= JSON.parse(text)[webPageUrl ];
              var AnnotationsBlock = document.createElement('div');

              AnnotationsBlock.id ="ImportedAnnotations";
              AnnotationsBlock.innerHTML=UserUploadedAnnotaions;
              document.body.appendChild(AnnotationsBlock);


              // Enable interactivity for all the imported annoations using jquery
              for(var dd1=0;dd1<AnnotationsBlock.childNodes.length;dd1++){
                for(var dd2=0;dd2<AnnotationsBlock.childNodes[dd1].childNodes.length;dd2++){

                  $('#'+AnnotationsBlock.childNodes[dd1].childNodes[dd2].id).mousedown(handle_mousedown);

                }

                  // allows user to delete the imported annotation by clicking the right click after user confirmation
                AnnotationsBlock.childNodes[dd1].addEventListener('contextmenu', function(ev) {
                if(confirm("Are you sure you want to delete this imported note?")){
                  ev.preventDefault();
                  ev.target.remove();
                  return false;
                }}, false);
              }
            })
          }

        /// End of upload-annotation block///

        /////////////// Hightlight + Annotate block //////////////////////
        // highlight and annotate  when Ctrl+1 key is pressed

        if(e.keyCode ==createNoteKeyCode){

              ////////// highlighting ///////////
            if(window.getSelection().rangeCount >0){
              var selection = window.getSelection();
              var range = selection.getRangeAt(0);
              var newNode = document.createElement("span");
              newNode.id = "popcorn"+note_count;
        //       newNode.setAttribute("style", "background-color:#d9ffcc;");
//               newNode.addEventListener('mousedown', removeHighlight);
//               function removeHighlight(){
//                 newNode.setAttribute("style", "");  //removes the highlight
//               }


              newNode.appendChild(range.extractContents());``
              range.insertNode(newNode);
//               toggleHighlight = true;

            }


            ////////// annotate ///////////
            if(window.getSelection().rangeCount >0){
              var newNode1 = document.createElement("div");
              newNode1.classList.add("ui-widget-content");
              document.body.appendChild(newNode1)
              newNode1.setAttribute("style", "display: inline-block;overflow:auto;");

             // allows user to delete the imported annotation by clicking the right click after user confirmation
            newNode1.addEventListener('contextmenu', function(ev) {
            if(confirm("Are you sure you want to delete this note?")){
              ev.preventDefault();
              ev.target.remove();
              return false;
            }}, false);



              /*
              ///////// annotation using pell note ///////////
              with HTML: For tests only
              newNode1.innerHTML= `
              <div id=`+"tooltip"+note_count + ` >
              <div>
                HTML output:
                <div id="html-output" style="white-space:pre-wrap;"></div>
              </div>
              </div>
                `;
              */
              newNode1.innerHTML= `
              <div id=`+"tooltip"+note_count + ` class="pell" >
              </div>
              `;

              document.getElementById("tooltip"+note_count).setAttribute("style","height: 130px; width: 250px;\
              border: none;color: black;  padding: 15px 15px; text-align: enter;\
              text-decoration: none;  display: inline-block; overflow:auto;resize:both;background-color:"+defaultNoteColor+";font-size:"+ defaultFont +";opacity:"+defaultOpacity)

              const editor = pell.init({
                element: document.getElementById("tooltip"+note_count),
                onChange: html => {
        //           document.getElementById('markdown-output').innerHTML = turndown(html)
                },
                defaultParagraphSeparator: 'p',
                styleWithCSS: true,
                actions: [
                  'bold',
        //           'italic',
        //           'underline',
        //           'strikethrough',
        //           'heading1',
        //           'heading2',
        //           'paragraph',
                  'quote',
                  'olist',
                  'ulist',
                  'code',
                  {
                    icon: '&#128247;',
                    title: 'Image',
                    result: () => {
                      const url = window.prompt('Enter the image URL')
                      //this implemention is different from the pell documentation to account for resizing
                      if (url) document.execCommand('insertHTML',false, `
                      <div style=" resize: both; overflow:auto;">
                        <img width=100% height=100% src=`+url+"></div><br><br> ")
                    }
                  },

        //           {
        //             icon: '&#9751;',
        //             title: 'Toggle color',
        //             result: () => {
        // //               let userInputColor=prompt("Enter color you want to set in HTML code (e.g. #d9ccff for purple):");
        // //               console.log(userInputColor);
        //               if(document.getElementById(event.target.parentNode.parentNode.id).style.backgroundColor=="#ffffcc"){

        //                  document.getElementById(event.target.parentNode.parentNode.id).style.backgroundColor="#d9ccff";

        //               }

        //             }
        //           },


        //           {
        //             icon: '&#10006;',
        //             title: 'Destroy note',
        //             result: () => {
        //               $( '#'+"tooltip" + event.target.className.slice(-1) ).remove(); // destroys the note
        //               $( '#'+"popcorn" + event.target.className.slice(-1) ).attr("style", "");  //removes the highlight

        //             console.log("tooltip" +  event.target.className)

        //           }
        //           },
                  {
                    icon: '&#10154;',
                    title: 'Send note via mqtt',
                    result: () => {

                      sendMqttMessage(event.target.parentNode.parentNode.parentNode.outerHTML);

                    }
                  }

                ],
                classes: {
                  actionbar: 'pell-actionbar',
                  button: 'pell-button',
                  content: 'pell-content',
                  selected: 'pell-button-selected'
                }
              })

              editor.content.innerHTML = '<br><br><br><br><br><br>'

             ////// popper js block ///////////////////////
              const popcorn = document.querySelector("#"+"popcorn"+note_count);
              const tooltip = document.querySelector('#'+"tooltip"+note_count);
              const popper_instance = Popper.createPopper(popcorn, tooltip, {
                placement: 'auto',
                  modifiers: [
                    {
                      name: 'offset',
                      options: {
                      offset: [0, 0],
                      },
                    },
                    { name: 'eventListeners', enabled: false }
                  ],
              });

              $('#'+"tooltip"+note_count).mousedown(handle_mousedown); // move popper

             //////////// drag the annotation across the document ///////////
            /// from stackexchange - https://stackoverflow.com/questions/38405569/jquery-calling-function-to-parent-element
            function handle_mousedown(e){
              window.my_dragging = {};
              my_dragging.pageX0 = e.pageX;
              my_dragging.pageY0 = e.pageY;
              my_dragging.elem = this;
              my_dragging.offset0 = $(this).offset();


              function handle_dragging(e){
                if(e.shiftKey){
                var left = my_dragging.offset0.left + (e.pageX - my_dragging.pageX0);
                var top = my_dragging.offset0.top + (e.pageY - my_dragging.pageY0);
                $(my_dragging.elem)
                .offset({top: top, left: left});
              }
              }

              function handle_mouseup(e){
                $('body')
                .off('mousemove', handle_dragging)
                .off('mouseup', handle_mouseup);
              }
              $('body')
                  .on('mouseup', handle_mouseup)
                  .on('mousemove', handle_dragging);
            }

              note_count+=1; // update note counter

            }
          }
       /// End of Hightlight + Annotate block  ///
    }
}



// Your CSS as text
var styles = `
.highlighter--highlighted.highlighter--hovered {
    box-shadow: 0 1px 0 grey;
}

#highlighter--hover-tools {
    position: fixed;
    padding-bottom: 8px;
    z-index: 10000;
}

#highlighter--hover-tools--container {
    position: relative;
    border: solid 1px #777777;
    border-radius: 4px;
    padding: 1px 0;
    background-color: white;
    width: 94px; /* When changing this, also update moveToolbarToHighlight() in hoverTools.js */
    height: 37px;
    display: flex;
    justify-content: space-around;
    align-items: center;
    box-shadow: 1px 1px 2px #bdbdbd;
}

/* Generated with http://www.cssarrowplease.com/ */
#highlighter--hover-tools--container:after, #highlighter--hover-tools--container:before {
    top: 100%;
    left: 50%;
    border: solid transparent;
    content: " ";
    height: 0;
    width: 0;
    position: absolute;
    pointer-events: none;
}

#highlighter--hover-tools--container:after {
    border-color: rgba(255, 255, 255, 0);
    border-top-color: white;
    border-width: 5px;
    margin-left: -5px;
}
#highlighter--hover-tools--container:before {
    border-color: rgba(119, 119, 119, 0);
    border-top-color: #777777;
    border-width: 6px;
    margin-left: -6px;
}

.highlighter--icon {
    display: inline-block;
    width: 25px;
    height: 25px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    cursor: pointer;
    filter: opacity(0.7);
    margin: 0 4px;
}

.highlighter--icon:hover {
    filter: opacity(0.92);
}

.highlighter--icon-copy {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-clipboard' viewBox='0 0 16 16'%3E%3Cpath d='M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z'/%3E%3Cpath d='M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z'/%3E%3C/svg%3E");
}

/* https://icons.getbootstrap.com/icons/trash/ and https://yoksel.github.io/url-encoder/ */
.highlighter--icon-delete {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-trash' viewBox='0 0 16 16'%3E%3Cpath d='M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z'/%3E%3Cpath fill-rule='evenodd' d='M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z'/%3E%3C/svg%3E");
}

.highlighter--icon-change-color {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-palette' viewBox='0 0 16 16'%3E%3Cpath d='M8 5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm4 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zM5.5 7a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm.5 6a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z'/%3E%3Cpath d='M16 8c0 3.15-1.866 2.585-3.567 2.07C11.42 9.763 10.465 9.473 10 10c-.603.683-.475 1.819-.351 2.92C9.826 14.495 9.996 16 8 16a8 8 0 1 1 8-8zm-8 7c.611 0 .654-.171.655-.176.078-.146.124-.464.07-1.119-.014-.168-.037-.37-.061-.591-.052-.464-.112-1.005-.118-1.462-.01-.707.083-1.61.704-2.314.369-.417.845-.578 1.272-.618.404-.038.812.026 1.16.104.343.077.702.186 1.025.284l.028.008c.346.105.658.199.953.266.653.148.904.083.991.024C14.717 9.38 15 9.161 15 8a7 7 0 1 0-7 7z'/%3E%3C/svg%3E");
}

.highlighter--separator {
    display: inline-block;
    height: 22px;
    width: 0px;
    border-right: solid 1px #bfbfbf;
}
`

var styleSheet = document.createElement("style")
styleSheet.type = "text/css"
styleSheet.innerText = styles
document.head.appendChild(styleSheet)



///// Highlighting tools
function elementFromQuery(storedQuery) {
  const re = />textNode:nth-of-type\(([0-9]+)\)$/i;
  const result = re.exec(storedQuery);

  if (result) { // For text nodes, nth-of-type needs to be handled differently (not a valid CSS selector)
      const textNodeIndex = parseInt(result[1]);
      storedQuery = storedQuery.replace(re, "");
      const parent = $(storedQuery)[0];
      if (!parent)
          return undefined;
      return parent.childNodes[textNodeIndex];
  } else {
      return $(storedQuery)[0];
  }
}

// From an DOM element, get a query to that DOM element
function getQuery(element) {
  if (element.id)
      return '#' + escapeCSSString(element.id);
  if (element.localName === 'html')
      return 'html';

  const parent = element.parentNode;

  let index;
  const parentSelector = getQuery(parent);
  // The element is a text node
  if (!element.localName) {
      // Find the index of the text node:
      index = Array.prototype.indexOf.call(parent.childNodes, element);
      return parentSelector + '>textNode:nth-of-type(' + index + ')';
  } else {
      const jEl = $(element);
      index = jEl.parent().find('>' + element.localName).index(jEl) + 1;
      return parentSelector + '>' + element.localName + ':nth-of-type(' + index + ')';
  }
}

// Colons and spaces are accepted in IDs in HTML but not in CSS syntax
// Similar (but much more simplified) to the CSS.escape() working draft
function escapeCSSString(cssString) {
  return cssString.replace(/(:)/g, "\\$1");
}


function load(highlightVal, highlightIndex, noErrorTracking) { // noErrorTracking is optional
  const selection = {
      anchorNode: elementFromQuery(highlightVal.anchorNode),
      anchorOffset: highlightVal.anchorOffset,
      focusNode: elementFromQuery(highlightVal.focusNode),
      focusOffset: highlightVal.focusOffset
  };

  const selectionString = highlightVal.string;
  const container = elementFromQuery(highlightVal.container);
  const color = highlightVal.color;

  if (!selection.anchorNode || !selection.focusNode || !container) {
      if (!noErrorTracking) {
          addHighlightError(highlightVal, highlightIndex);
      }
      return false;
  } else {
      let success = false;
      success = highlight(selectionString, container, selection, color, highlightIndex);

      if (!noErrorTracking && !success) {
          addHighlightError(highlightVal, highlightIndex);
      }
      return success;
  }
}

function loadAll(url, alternativeUrl) { /* eslint-disable-line no-redeclare, no-unused-vars */
    let result = JSON.parse(localStorage.getItem(window.location.hostname + window.location.pathname));

    console.log("loadallllll");
    let highlights = [];
    highlights = highlights.concat(result.highlights[url] || []);

    if (!highlights) return;

        for (let i = 0; i < highlights.length; i++) {
        load(highlights[i], i, true);
        }
    };


//         { highlights: {} }, (result) => {
//     let highlights = [];
//     console.log("i am in load all function");

//     // Because of a bug in an older version of the code, some highlights were stored
//     // using a key that didn't correspond to the full page URL. To fix this, if the
//     // alternativeUrl exists, try to load highlights from there as well
//     if (alternativeUrl) {
//     highlights = highlights.concat(result.highlights[alternativeUrl] || []);
//     }
//     alternativeUrlIndexOffset = highlights.length;

//     highlights = highlights.concat(result.highlights[url] || []);

//     if (!highlights) return;

//         for (let i = 0; i < highlights.length; i++) {
//         load(highlights[i], i);
//         }
//     });
// }


function store(selection, container, url, color, callback) {
      let result = JSON.parse(localStorage.getItem(window.location.hostname + window.location.pathname));
  		console.log(result==null);
  		let highlights = {};
  		if(result){
      	highlights = result.highlights;
      }

  
      console.log("i am in store function");
      if (!highlights[url])
          highlights[url] = [];


      const count = highlights[url].push({
          version: "1.0",
          string: selection.toString(),
          container: getQuery(container),
          anchorNode: getQuery(selection.anchorNode),
          anchorOffset: selection.anchorOffset,
          focusNode: getQuery(selection.focusNode),
          focusOffset: selection.focusOffset,
          color: color
      });
//       chrome.storage.local.set({ highlights });
      localStorage.setItem(window.location.hostname + window.location.pathname, JSON.stringify({ highlights }));

      if (callback)
          callback(count - 1);
        //   callback(count - 1 + alternativeUrlIndexOffset);

}

//---error...
var MAX_RETRY_TIME = 10000; // Stop trying to highlight after this time (in ms)
var RETRY_INTERVAL = 500;

var highlightErrors = [];

function addHighlightError(highlight, highlightIndex) {
    highlightErrors.push({
        highlight,
        highlightIndex,
        errorTime: Date.now()
    });
}

setInterval(() => {
    highlightErrors.forEach((highlightError, idx) => {
        if (Date.now() - highlightError.errorTime > MAX_RETRY_TIME) { // Stop the search
            highlightErrors.splice(idx, 1);
        } else { // Keep retrying
            const success = load(highlightError.highlight, highlightError.highlightIndex, true);
            if (success) {
                highlightErrors.splice(idx, 1);
            }
        }
    });
}, RETRY_INTERVAL);



//---highlight functions
var HIGHLIGHT_CLASS = 'highlighter--highlighted';
var DELETED_CLASS = 'highlighter--deleted';
var highlightColor = 'cyan';
var highlightCount = 1;

//var webPageUrl = window.location.href.replace(/(^\w+:|^)\/\//, '');

function highlight(selString, container, selection, color, highlightIndex) {

    const highlightInfo = {
        color: color ? color : "yellow",
        highlightIndex: highlightIndex,
        selectionString: selString,
        selectionLength: selString.length,
        container: $(container),
        anchor: $(selection.anchorNode),
        anchorOffset: selection.anchorOffset,
        focus: $(selection.focusNode),
        focusOffset: selection.focusOffset
    };

    /**
    * STEPS:
    * 1 - Use the offset of the anchor/focus to find the start of the selected text in the anchor/focus element
    *     - Use the first of the anchor of the focus elements to appear
    * 2 - From there, go through the elements and find all Text Nodes until the selected text is all found.
    *     - Wrap all the text nodes (or parts of them) in a span DOM element with special highlight class name and bg color
    * 3 - Deselect text
    * 4 - Attach mouse hover event listeners to display tools when hovering a highlight
    */

    // Step 1 + 2:
    recursiveWrapper(highlightInfo);

    // Step 3:
    if (selection.removeAllRanges)
        selection.removeAllRanges();

    // Step 4:
    const parent = highlightInfo.container.parent();
    parent.find(`.${HIGHLIGHT_CLASS}`).each((i, el) => {
        el.addEventListener('mouseenter', onHighlightMouseEnterOrClick);
        el.addEventListener('click', onHighlightMouseEnterOrClick);
        el.addEventListener('mouseleave', onHighlightMouseLeave);
    });



    return true; // No errors. 'undefined' is returned by default if any error occurs during this method's execution, like if 'content.replace' fails by 'content' being 'undefined'
}

function recursiveWrapper(highlightInfo) {
    return _recursiveWrapper(highlightInfo, false, 0); // Initialize the values of 'startFound' and 'charsHighlighted'
}

function _recursiveWrapper(highlightInfo, startFound, charsHighlighted) {

    const { container, anchor, focus, anchorOffset, focusOffset, color, highlightIndex, selectionString, selectionLength } = highlightInfo;

    container.contents().each((index, element) => {
        if (charsHighlighted >= selectionLength) return; // Stop early if we are done highlighting

        if (element.nodeType === Node.TEXT_NODE) {
            let startIndex = 0;

            // Step 1:
            // The first element to appear could be the anchor OR the focus node,
            // since you can highlight from left to right or right to left
            if (!startFound) {
                if (anchor.is(element)) {
                    startFound = true;
                    startIndex = anchorOffset;
                }
                if (focus.is(element)) {
                    if (startFound) // If the anchor and the focus elements are the same, use the smallest index
                        startIndex = Math.min(anchorOffset, focusOffset);
                    else {
                        startFound = true;
                        startIndex = focusOffset;
                    }
                }
            }

            // Step 2:
            if (startFound && charsHighlighted < selectionLength) {
                const nodeValue = element.nodeValue;
                const nodeValueLength = element.nodeValue.length;
                const parent = element.parentElement;

                let firstSplitTextEl = null;
                let firstSplitIndex = -1;
                let secondSplitTextEl = null;

                // Go over all characters to see if they match the selection.
                // This is done because the selection text and node text contents differ.
                for (let i = 0; i < nodeValueLength; i++) {
                    if (i === startIndex) {
                        firstSplitTextEl = element.splitText(i);
                        firstSplitIndex = i;
                    }
                    if (charsHighlighted === selectionLength) {
                        secondSplitTextEl = firstSplitTextEl.splitText(i - firstSplitIndex);
                        break;
                    }

                    if (i >= startIndex && charsHighlighted < selectionLength) {
                        // Skip whitespaces as they often cause trouble (differences between selection and actual text)
                        while (charsHighlighted < selectionLength && selectionString[charsHighlighted].match(/\s/))
                            charsHighlighted++;

                        if (selectionString[charsHighlighted] === nodeValue[i])
                            charsHighlighted++;
                    }
                }

                // If textElement is wrapped in a .highlighter--highlighted span, do not add this highlight
                if (parent.classList.contains(HIGHLIGHT_CLASS)) {
                    parent.normalize(); // Undo any 'splitText' operations
                    return;
                }

                if (firstSplitTextEl) {
                    const highlightNode = document.createElement('span');
                    highlightNode.classList.add((color === 'inherit') ? DELETED_CLASS : HIGHLIGHT_CLASS);
                    highlightNode.setAttribute('style', `background-color: ${color};`);
                    highlightNode.setAttribute('data-highlight-id', highlightIndex);
                    highlightNode.textContent = firstSplitTextEl.nodeValue;

                    firstSplitTextEl.remove();
                    const insertBeforeElement = secondSplitTextEl || element.nextSibling;
                    parent.insertBefore(highlightNode, insertBeforeElement);
                }
            }
        } else {
            highlightInfo.container = $(element);
            [startFound, charsHighlighted] = _recursiveWrapper(highlightInfo, startFound, charsHighlighted);
        }
    });

    return [startFound, charsHighlighted];
}


document.addEventListener('keydown', highlightText);

function highlightText(e) {
    if(e.keyCode ==49){
    // Restrict the scope of the variables to this file
    const selection = window.getSelection();
    const selectionString = selection.toString();

    if (selectionString) { // If there is text selected

        let container = selection.getRangeAt(0).commonAncestorContainer;

        // Sometimes the element will only be text. Get the parent in that case
        // TODO: Is this really necessary?
        while (!container.innerHTML) {
            container = container.parentNode;
        }

        const color = highlightColor;
        // highlightCount++;
        // let highlightInfo = {
        //     url:webPageUrl,
        //     highlightIndex: highlightCount,
        //     string: selection.toString(),
        //     container: getQuery(container),
        //     anchorNode: getQuery(selection.anchorNode),
        //     anchorOffset: selection.anchorOffset,
        //     focusNode: getQuery(selection.focusNode),
        //     focusOffset: selection.focusOffset,
        //     color: color ? color : "yellow"
        // };

        // let highlightInfo = {
        //     url:webPageUrl,
        //     color: color ? color : "yellow",
        //     highlightIndex: 1,
        //     string: selectionString,
        //     stringLength: selectionString.length,
        //     container: $(container),
        //     anchor: $(selection.anchorNode),
        //     anchorOffset: selection.anchorOffset,
        //     focus: $(selection.focusNode),
        //     focusOffset: selection.focusOffset
        // };
        store(selection, container, window.location.hostname + window.location.pathname, color, (highlightIndex) => {
            highlight(selectionString, container, selection, color, highlightIndex);
        });

        //console.log(JSON.stringify(highlightInfo));
        //console.log(highlightInfo);
    }}
};





// -- hover tools
var hoverToolEl = null;
var hoverToolTimeout = null;
var currentHighlightEl = null;
var highlightClicked = false;
var copyBtnEl = null;
var changeColorBtnEl = null;
var deleteBtnEl = null;

var newNode1 = document.createElement("div");
newNode1.classList.add("ui-widget-content");
document.body.appendChild(newNode1)
let hoverHtml = (`<div id='highlighter--hover-tools'>
    <div id='highlighter--hover-tools--container'>
        <div class="highlighter--icon highlighter--icon-copy" title='Copy'></div>
        <div class="highlighter--separator"></div>
        <div class="highlighter--icon highlighter--icon-change-color" title='Change Color'></div>
        <div class="highlighter--separator"></div>
        <div class="highlighter--icon highlighter--icon-delete" title='Delete'></div>
    </div>
    </div> `)
hoverToolEl = $(hoverHtml);
hoverToolEl.hide().appendTo('body');
hoverToolEl[0].addEventListener('mouseenter', onHoverToolMouseEnter);
hoverToolEl[0].addEventListener('mouseleave', onHighlightMouseLeave);

copyBtnEl = hoverToolEl.find('.highlighter--icon-copy')[0];
deleteBtnEl = hoverToolEl.find('.highlighter--icon-delete')[0];
changeColorBtnEl = hoverToolEl.find('.highlighter--icon-change-color')[0];
copyBtnEl.addEventListener('click', onCopyBtnClicked);
deleteBtnEl.addEventListener('click', onDeleteBtnClicked);
changeColorBtnEl.addEventListener('click', onChangeColorBtnClicked);

// Allow clicking outside of a highlight to unselect
window.addEventListener('click', function (e) {
    if (e.target.classList.contains('highlighter--highlighted')) return;
    if (e.target.classList.contains('highlighter--icon-change-color')) return;
    hide();
});

window.addEventListener("scroll", function (e) {
    if (highlightClicked) {
        moveToolbarToHighlight(currentHighlightEl);
    }
});

function onHighlightMouseEnterOrClick(e) {
    const newHighlightEl = e.target;
    const newHighlightId = newHighlightEl.getAttribute('data-highlight-id');

    // If the previous action was a click but now it's a mouseenter, don't do anything
    if (highlightClicked && e.type !== 'click') return;

    highlightClicked = e.type === 'click';

    // Clear any previous timeout that would hide the toolbar, and
    if (hoverToolTimeout !== null) {
        clearTimeout(hoverToolTimeout);
        hoverToolTimeout = null;

        if (newHighlightId === currentHighlightEl.getAttribute('data-highlight-id')) return;
    }

    currentHighlightEl = newHighlightEl;

    // Position (and show) the hover toolbar above the highlight
    moveToolbarToHighlight(newHighlightEl, e.clientX);

    // Remove any previous borders and add a border to the highlight (by id) to clearly see what was selected
    $('.highlighter--hovered').removeClass('highlighter--hovered');
    $(`.highlighter--highlighted[data-highlight-id='${newHighlightId}']`).addClass('highlighter--hovered');
}

function onHighlightMouseLeave(e) {
    if (!highlightClicked) {
        hoverToolTimeout = setTimeout(hide, 170);
    }
}

function moveToolbarToHighlight(highlightEl, cursorX) { // cursorX is optional, in which case no change is made to the x position of the hover toolbar
    const boundingRect = highlightEl.getBoundingClientRect();
    const toolWidth = 94; // When changing this, also update the width in css #highlighter--hover-tools--container

    const hoverTop = boundingRect.top - 45;
    hoverToolEl.css({ top: hoverTop });

    if (cursorX !== undefined) {
        let hoverLeft = null;
        if (boundingRect.width < toolWidth) {
            // center the toolbar if the highlight is smaller than the toolbar
            hoverLeft = boundingRect.left + boundingRect.width / 2 - toolWidth / 2
        } else if (cursorX - boundingRect.left < toolWidth / 2) {
            // If the toolbar would overflow the highlight on the left, snap it to the left of the highlight
            hoverLeft = boundingRect.left;
        } else if (boundingRect.right - cursorX < toolWidth / 2) {
            // If the toolbar would overflow the highlight on the right, snap it to the right of the highlight
            hoverLeft = boundingRect.right - toolWidth;
        } else {
            // Else, center the toolbar above the cursor
            hoverLeft = cursorX - toolWidth / 2;
        }

        hoverToolEl.css({ left: hoverLeft });
    }

    hoverToolEl.show()
}

function hide() {
    $('.highlighter--hovered').removeClass('highlighter--hovered');
    hoverToolEl.hide();
    hoverToolTimeout = null;
    highlightClicked = false;
}

function onHoverToolMouseEnter(e) {
    if (hoverToolTimeout !== null) {
        clearTimeout(hoverToolTimeout);
        hoverToolTimeout = null;
    }
}

function onCopyBtnClicked(e) {
    const highlightId = currentHighlightEl.getAttribute('data-highlight-id');
    const highlights = document.querySelectorAll(`.highlighter--highlighted[data-highlight-id='${highlightId}']`);
    const highlightText = Array.from(highlights).map((el) => el.textContent.replace(/\s+/gm, ' ')).join(''); // clean up whitespace
    navigator.clipboard.writeText(highlightText);
}

function onDeleteBtnClicked(e) {
    const highlightId = currentHighlightEl.getAttribute('data-highlight-id');
    const highlights = $(`.highlighter--highlighted[data-highlight-id='${highlightId}']`);
    $('.highlighter--hovered').removeClass('highlighter--hovered');
    hoverToolEl.hide();
    hoverToolTimeout = null;

    highlights.css('backgroundColor', 'inherit'); // Change the background color attribute
    highlights.removeClass(HIGHLIGHT_CLASS).addClass(DELETED_CLASS); // Change the class name to the 'deleted' version
    //update(highlightId, window.location.hostname + window.location.pathname, window.location.pathname, 'inherit'); // update the value in the local storage

    highlights.each((_, el) => { // Finally, remove the event listeners that were attached to this highlight element
        el.removeEventListener('mouseenter', onHighlightMouseEnterOrClick);
        el.removeEventListener('click', onHighlightMouseEnterOrClick);
        el.removeEventListener('mouseleave', onHighlightMouseLeave);
    });

}

 function onChangeColorBtnClicked(e) {
    const highlightId = currentHighlightEl.getAttribute('data-highlight-id');
    const highlights = $(`.highlighter--highlighted[data-highlight-id='${highlightId}']`);
    const colors = ["yellow", "cyan", "lime", "magenta"];
    const currentColor = highlights[0].style.backgroundColor;
    const newColor = colors[(colors.indexOf(currentColor) + 1) % 4];
    highlights.css('backgroundColor', newColor); // Change the background color attribute
    highlightColor = newColor;

    //update(highlightId, window.location.hostname + window.location.pathname, window.location.pathname, newColor); // update the value in the local storage
 }
